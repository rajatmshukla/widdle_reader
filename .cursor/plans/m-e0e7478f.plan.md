<!-- e0e7478f-408b-4bc1-8b73-9609fad67346 0187b299-8aa3-43cb-9c3c-5c7034132767 -->
# M4B Chapters & Metadata Plan

### Approach

- Keep multi-file playback; add single-file M4B with in-file chapter navigation (1a/4a).
- Use FFprobe via `ffmpeg_kit_flutter_min_gpl` to read chapters (2a, read-only first 3a).
- Represent chapters as segments: source file + start/end; play using `ClippingAudioSource` for accurate boundaries and seamless next/previous.

### Minimal Model Changes

- File: `lib/models/chapter.dart`
```dart
class Chapter {
  final String id;            // unique (e.g., "$sourcePath#<startMs>")
  final String title;
  final String audiobookId;
  final String sourcePath;    // backing audio file (M4B or per-file chapter)
  final Duration? duration;   // UI display; for segments = end-start
  final Duration? start;      // null for per-file chapters
  final Duration? end;        // optional; null = to EOF/next chapter
}
```

- File: `lib/models/audiobook.dart`
  - Add: `final bool isSingleFileAudiobook;` (default false)

### M4B Chapter Reader

- New: `lib/services/m4b_chapter_service.dart`
  - `Future<List<Chapter>> readChapters(String filePath, String audiobookId)`
  - Use `FFprobeKit.getMediaInformation(filePath)`; read `chapters[*].start_time`, `end_time`, and `tags.title` (fallback "Chapter N").
  - Normalize/sort by start, clamp negatives, fill missing end from next start or total duration.

### Metadata Integration

- File: `lib/services/metadata_service.dart`
  - When only one `.m4b` exists in folder: call `M4bChapterService.readChapters`.
  - Compute `totalDuration = sum(chapter.duration)`.
  - Extract cover art/author as today (metadata retriever) and set `isSingleFileAudiobook = true`.
  - Fallback: if FFprobe fails or no chapters → single chapter for whole file.

### Playback Integration

- File: `lib/services/simple_audio_service.dart`
  - In `loadChapter(index, startPosition)`, use `chapter.sourcePath` for file checks.
  - Build source with clipping when `start != null`:
```dart
final base = AudioSource.uri(Uri.file(chapter.sourcePath), tag: mediaItem);
final source = (chapter.start != null)
  ? ClippingAudioSource(start: chapter.start!, end: chapter.end, child: base)
  : base;
await _player.setAudioSource(source, initialPosition: startPosition);
```

  - Existing `ProcessingState.completed → skipToNext()` already handles chapter transitions.

### Caching Updates

- File: `lib/providers/audiobook_provider.dart`
  - Persist/restore `sourcePath`, `startMs`, `endMs` for chapters in `_cacheBasicBookInfo`, `_cacheDetailedMetadata`, `_createAudiobookFromCachedInfo`, `_createAudiobookFromDetailedCache`.

### UI

- `lib/screens/simple_player_screen.dart`: No structural changes. List shows chapter titles/durations already. Navigation works via `skipToChapter`.

### Dependency

- `pubspec.yaml`: add `ffmpeg_kit_flutter_audio:^6.x` (LGPL, audio-focused; ~15–25MB increase).

### Comparison vs seek-only approach

- ClippingAudioSource (recommended):
  - Pros: auto end-of-chapter completion, accurate boundaries, simpler logic; integrates with next/prev.
  - Cons: sets a new source per chapter (small overhead). 
- Seek-only:
  - Pros: keep one source loaded; very low switching overhead.
  - Cons: must implement manual end detection/timer, edge cases (drift, backward seeks), more code and bugs.

### Estimates

- Add dependency: 10 min
- Chapter model + Audiobook flag + caching: 1–1.5 h
- M4B probe service: 1.5–2.5 h
- Metadata integration: 1–2 h
- Playback integration: 1–2 h
- QA on sample M4B (no chapters, many chapters, odd tags): 1–2 h

Total: ~6–9 hours

### To-dos

- [ ] Add ffmpeg_kit_flutter_min_gpl to pubspec.yaml
- [ ] Extend Chapter with sourcePath, start, end and extras
- [ ] Create M4bChapterService using FFprobe to read chapters
- [ ] Integrate M4B parsing into MetadataService.getAudiobookDetails
- [ ] Use ClippingAudioSource in SimpleAudioService.loadChapter
- [ ] Persist startMs/endMs/sourcePath; restore in caching flows
- [ ] QA with real .m4b: chapters list, seek, prev/next, resume